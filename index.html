<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Type Driven Development</title>

    <meta name="description" content="Type Driven Development">
    <meta name="author" content="Frank Thomas">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style type="text/css">
      .highlight {
        font-weight: bold !important; 
        color: orange;
      }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

<!--
* die Grenze zwischen Typ- und Werteebene verschwimmt bzw. verschwindet
* Typen klassifizieren Werte. Werden die Typen präziser, werden weniger
  Werte durch sie klassifiziert.
* Präzise Typen geben dem Programmierer Sicherheit bzw mehr Informationen
  über den Aufbau der Werte:
  * Object
  * Long
  * Optional<Long>
  * Optional<AuftragId>
  * SizedList<5, AuftragId>
* abhängig typisierte Programmiersprachen erlauben Werte auf Typebene
  zu verwenden und damit noch präziser zu werden
  
* Tests beweisen Spezialfälle
* Typen sind allgemeine Aussagen und Werte dieser Typen sind Beweise dieser Aussagen.
* types and expressions are part of the same language, they use the same syntax
-->

  <body>

    <div class="reveal">

      <div class="slides">
			
        <section>
          <h2>Type Driven Development</h2>
          <h3>Eine Einführung in Idris</h3>
          <p>Frank Thomas</p>
        </section>
        
        <section>
          <img src="img/Idris.png" />	
        </section>
        
        <section>
          <h3>Abhängige Typen</h3>
          https://en.wikipedia.org/wiki/Dependent_type:
          <blockquote>
            In computer science and logic, a <span class="highlight">dependent type</span> is a
            <span class="highlight">type</span> that <span class="highlight">depends on a value</span>.
            [...] In functional programming languages like ATS, Agda, Idris and Epigram,
            dependent types <span class="highlight">prevent bugs</span> by allowing
            <span class="highlight">extremely expressive types</span>.
          </blockquote>
        </section>
        
        <!-- 
        In Coq formuliert man Datentypdefinitionen und ausführbare Programmteile
        sowie mathematische Aussagen und Beweise. Die getroffenen Aussagen beziehen
        sich gewöhnlich auf die definierten Funktionen. Coq überprüft die formale
        Richtigkeit von Beweisen mithilfe seines auch sonst benutzten Typprüfers.
        -->
        
        <section>
          <h3>Bugs in Produktion können fatal sein</h3>
          <img src="img/MCO.png" />
          <!--
          metrische Einheit: N*s (Newton Sekunde)
          imperiale Einheit: lb*s (Pound-force Sekunde)
          -->
        </section>
        
        <section>
          <h3>Verifizierter Microkernel</h3>
          <img src="img/seL4.png" />
          <!--
          * beweisbar keine Speicherfehler und Zeigerfehler
          * Kein "kernel panic" oder "Blue Screen of Death"
          * 26 2/3 * mehr Beweiscode als Programmcode
          -->
        </section>
        
        <section>
          <h3>Verifizierter Compiler</h3>
          <img src="img/CompCert.png" />
          <!--
          * Der erzeugte Maschinencode verhält sich exakt wie durch den Sourcecode vorgegeben
          
          http://compcert.inria.fr/motivations.html
          Bugs in compilers do occur and can cause incorrect executable code to be silently
          generated from a correct source program. In other words, a buggy compiler can insert
          bugs in the programs that it compiles. This phenomenon is called miscompilation.
          
            We created a tool that generates random C programs, and then spent two and a half
            years using it to find compiler bugs. So far, we have reported more than 325
            previously unknown bugs to compiler developers. Moreover, every compiler that we
            tested has been found to crash and also to silently generate wrong code when
            presented with valid inputs. (PLDI 2011)
          
          For non-critical, "everyday" software, miscompilation is an annoyance but not a major
          issue: bugs introduced by the compiler are negligible compared to those already present
          in the source program. The situation changes dramatically, however, for safety-critical
          or mission-critical software, where human lives, critical infrastructures, or
          highly-sensitive information are at stake.
          -->
        </section>
        
        <section>
          <h3>Verifizierter Webbrowser</h3>
          <img src="img/Quark.png" />
          
          <!--
          It consists of a small browser kernel which mediates access to system resources
          for all other browser components. These other components run in sandboxes which
          only allow the component to communicate with the kernel. In this way, Quark is
          able to make strong guarantees about a million lines of code (e.g., the renderer,
          JavaScript implementation, JPEG decoders, etc.) while only using a proof assistant
          to reason about a few hundred lines of code for the Quark kernel. 
          -->
        </section>
        
        <section>
          <h3>Idris Syntax</h3>

          Java
          <pre><code>
    static &lt;T> Optional&lt;T> lastOption(List&lt;T> list) {
      if (list.isEmpty())
        return Optional.empty();
      else
        return Optional.of(list.get(list.size() - 1));
    }
          </code></pre>

          Idris
          <pre><code>
    lastOption : List a -> Maybe a
    lastOption       []  = Nothing
    lastOption (x :: []) = Just x
    lastOption (x :: xs) = lastOption xs
          </code></pre>
        </section>
      
        <section>
          <h1>Live Demo</h1>
        </section>
      
        <section>
          <p>
            <img src="img/MEAP.png" />
          </p>
          <p>
            <a href="https://www.manning.com/books/type-driven-development-with-idris">Type-Driven Development with Idris</a>
            <br />
            <small>https://www.manning.com/books/type-driven-development-with-idris</small>
            <br />
            Idris: <a href="http://www.idris-lang.org/">http://www.idris-lang.org/</a>
          </p>
        </section>

        <section style="text-align: left;">
          <h1>THE END</h1>
            - Slides: <a href="http://fthomas.github.io/tdd-talk/">http://fthomas.github.io/tdd-talk/</a><br />
            - Code: <a href="https://github.com/fthomas/tdd-talk">https://github.com/fthomas/tdd-talk</a>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
